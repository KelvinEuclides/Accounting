package com.anje.kelvin.aconting.data.repository

import com.anje.kelvin.aconting.data.dao.ItemDao
import com.anje.kelvin.aconting.data.entity.Item
import com.anje.kelvin.aconting.data.entity.ItemEntity
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ItemRepository @Inject constructor(
    private val itemDao: ItemDao
) {
    fun getAllItems(): Flow<List<Item>> {
        return itemDao.getAllItems().map { entities ->
            entities.map { it.toDomainModel() }
        }
    }

    suspend fun getItemById(id: String): Item? {
        return itemDao.getItemById(id.toLongOrNull() ?: 0)?.toDomainModel()
    }

    suspend fun insertItem(item: Item) {
        itemDao.insertItem(item.toEntity())
    }

    suspend fun updateItem(item: Item) {
        itemDao.updateItem(item.toEntity())
    }

    suspend fun deleteItem(id: String) {
        itemDao.deleteItem(id.toLongOrNull() ?: 0)
    }

    suspend fun getItemsByUserId(userId: String): List<Item> {
        return itemDao.getItemsByUserId(userId.toIntOrNull() ?: 0).map { it.toDomainModel() }
    }
}

// Extension functions for mapping between domain and entity models
private fun ItemEntity.toDomainModel(): Item {
    return Item(
        id = id.toString(),
        name = nomeItem,
        totalQuantity = numItem,
        availableQuantity = itensDisponiveis,
        purchasePrice = preco,
        salePrice = precoUnidade,
        unit = unidadeDeMedida,
        userId = idUsuario.toString(),
        createdAt = Date() // Note: Original entity doesn't have createdAt
    )
}

private fun Item.toEntity(): ItemEntity {
    return ItemEntity(
        id = id.toLongOrNull() ?: 0,
        idUsuario = userId.toIntOrNull() ?: 0,
        nomeItem = name,
        preco = purchasePrice,
        precoUnidade = salePrice,
        unidadeDeMedida = unit,
        numItem = totalQuantity,
        itensDisponiveis = availableQuantity
    )
}